---
title: 2.4. Lane Composition
short-title: Lane Composition
description: "Lane Composition"
group: Getting Started
layout: documentation
redirect_from:
  - /rust/developer-guide/multiple-lanes
  - /rust/developer-guide/multiple-lanes.html
---

In this section of the guide, we'll develop an agent that exposes functionality to add or subtract from a stored numerical state. To do this we'll introduct a new `CommandLane` type and expand on two previously mentioned topics: `ValueLane`s and `Form`s.

For this section, simply copy the previous project to a new directory and then we can tweak it.

Add these two `use` declarations in our server crate:

```rust
use swim::{lane::CommandLane, form::Form};
```

And for our client crate:

```rust
use swimos_client::Form;
```

# Command Lanes

Command lanes are stateless lanes that provide a single event handler that may be registered, which, when invoked with the request payload (the _command_), returns an effect which may trigger updates to other lanes, update a database or any other functionality required.

The _command_ type can be any type that implements the [Form]({% link _rust_backend/forms.md %}) trait; including enumerations which enable the lane to react to many different types of commands and for this section, will be either an `Add` or `Sub` variant.

# Building the Agent

Before diving in to building the agent, lets consider the design. We have the following requirements:

- We need somewhere to store the state. We can use a `ValueLane<i64>` that's addressable using a URI of `"state"`
- We will need to be able to react to `Add(i64)` and `Sub(i64)` requests. There's two approaches that we could take to this:
  - Two separate `CommandLane<i64>`s; one addressable at a URI of `"add"` and the other at `"sub"`.
  - One command lane `CommandLane<Operation>` that is addressable at `"exec"`. Where `Operation` is an enumeration with two variants: `Add(i64)` and `Sub(i64)`.

The latter option is more sensible as it is simpler and all envelopes to agents are processed sequentially so there is no benefit to splitting this out. We can use the previously mentioned event handler and register one in the lifecyle of our agent and then match on the operation and update the state of the agent.

Before we can start modelling our agent, we'll need to define our `Operation` type and derive the necessary traits:

```rust
// Note how as this is a custom type we need to derive `Form` for it.
#[derive(Debug, Form, Copy, Clone)]
pub enum Operation {
    Add(i64),
    Sub(i64),
}
```

We can now define our agent as follows:

```rust
#[derive(AgentLaneModel)]
#[projections]
pub struct ExampleAgent {
    state: ValueLane<i64>,
    exec: CommandLane<Operation>,
}
```

The `#[projections]` macro derives an accessor for retreiving a lane by it's name, which is used when working with event handlers. For our above agent, it looks as follows:

```rust
impl ExampleAgent {
    pub const STATE: for<'a> fn(&'a Self) -> &'a ValueLane<i64> = |agent| &agent.state;
    pub const EXEC: for<'a> fn(&'a Self) -> &'a CommandLane<Operation> = |agent| &agent.exec;
}
```

We can now add our `on_command` event handler:

```rust
#[on_command(exec)]
pub fn on_command(
    &self,
    context: HandlerContext<ExampleAgent>,
    // Notice how we get a reference to the command envelope.
    operation: &Operation,
) -> impl EventHandler<ExampleAgent> {
    let operation = *operation;
    context
        // Get the current state of our `state` lane.
        .get_value(ExampleAgent::STATE)
        .and_then(move |state| {
            // Calculate the new state.
            let new_state = match operation {
                Operation::Add(val) => state + val,
                Operation::Sub(val) => state - val,
            };
            // Return an effect which updates the state of the `state` lane.
            context.set_value(ExampleAgent::STATE, new_state)
        })
}
```

When working with lifecycle event handlers, the `HandlerContext` provides utility functions for accessing and mutating the state of a lane. Above, we build up a combinator that gets the state of the lane and then returns an effect which mutates it.

# Client

We can reuse most of the work that we did in the previous agent tutorial and then add a new downlink for sending commands to our `exec` lane - we'll need to copy over our `Operation` enumeration too.

For our new `exec` downlink, we can add it as follows:

```rust
let exec_downlink = handle
    .value_downlink::<Operation>(exec_path)
    .downlink_config(DownlinkConfig::default())
    .open()
    .await
    .expect("Failed to open exec downlink");
```

To issue our command envelopes, we invoke the `set` function on the downlink:

```rust
exec_downlink.set(Operation::Add(1000)).await.unwrap();
exec_downlink.set(Operation::Sub(13)).await.unwrap();
```

# Running

Run the server and client applications as we did in the previous agent tutorial.

In our client terminal, we will see the following output:

```
Downlink linked
Downlink synced with: 0
Downlink event: 1000
Downlink event: 987
```

# Full code

The full code for this page is available at: [todo-link](todo-link).
